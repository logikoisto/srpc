# 设计
## 架构
1. 类似协议栈的实现,客户端与服务器分别分为三层,运行时/存根层/用户层
2. 运行时负责
    1. 封装网络通信细节,保证RPC调用的基本语义(尽可能的模拟本地调用)
    2. 动态绑定,通过服务端导出接口名称到底层的协调服务(如zk/etcd),客户端导入而发现接口实现的机器位置,通过名称约束使得服务端绑定对应的过程实现。
    3. 名称空间,维护一个由pb定义好的名称空间,构建一个路由表<接口名,函数指针>,当解析数据得到名称后,根据路由表找到对应的实现函数
    4. xxx
## 协议
1. 序列化:  使用`protobuf`进行序列化
2. 消息边界:消息前四个字节规定为消息的长度,基于消息长度读取一个消息单元
3. 消息结构:消息非常简单的由消息长度与消息内容组成,消息的内容中包含一个protobuf协议定义的结构对象
4. 压缩算法:目前不支持
5. 幂等性保证:
      * 当rpc返回结果时,其远程过程必须被恰好调用一次
      * 当rpc返回异常时,其远程过程可能被调用一次或者零次(存在网络异常)
## 并发模型
* 多协程事件驱动模型,多个`eventloop`可发挥并行优势(目前仅支持`epoll`).
* 与CPU核数相同的主协程拥有对用一端口独立的`sockte`对象`accept`TCP连接,并注册到独立的epoll对象中,每个独立的epoll对象对应一个`eventloop`,实现多协程多核事件循环。
* 每个事件循环非阻塞的读写数据
* 解决水平触发模式下
  1. 频繁写入事件的触发问题
  2. 多写协程操作相同数据包的竞争问题
  3. 与nginx相似的多epoll的惊群问题
  
## 编解码器
*  `eventloop` 异步执行处理逻辑,根据协议格式解码消息序列化为约定的RPC对象,利用反射构建的函数与协议path的对应映射关系,调用相应的执行函数
*  目前仅支持同步调用RPC服务

## TOTO List
- [x] `eopll` IO多路复用机制
- [x] 多核事件循环
- [x] 非阻塞读写网络数据包并整合后上传应用层
- [ ] 整合`protobuf`序列化协议,实现`RPC`服务接口调用
- [ ] 基于环形数组实现应用层IO缓冲区,减少内存分配与释放开销以及保证并发安全
- [ ] 完善RPC监控指标
- [ ] 支持轮询,随机等负载均衡机制
- [ ] 支持 连接池化,动态权重,健康检查,心跳
- [ ] 支持服务发现,分布式跟踪等运维特性
- [ ] 进行基准测试
